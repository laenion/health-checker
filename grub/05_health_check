#!/bin/sh
set -e

cat << EOF
# Only consider showing a fallback entry on the top level menu
if [ -z "\${chosen}" -a -z "\${boot_once}" ]; then
  # If flag is set on boot the last start seems to have failed - the flag
  # should have been cleared by userspace
  if [ "\${health_checker_flag}" -ge 1 ]; then
    # Reset flag; it will be set again by a supported menu entry.
    # This prevents getting stuck in a loop when booting an entry that
    # doesn't support this flag yet.
    health_checker_flag=0
    if [ "\${env_block}" ] ; then
      save_env -f "\${env_block}" health_checker_flag
    fi

    # health_checker_lastok contains the snapshot number of the latest
    # successfully booted snapshot and is stored into the grubenv by user
    # space. Previously the variable was stored in /var/lib/misc; to enable a
    # smooth transition including the possibility to roll back keep the old
    # code as a fallback.
    if [ -z "\${health_checker_lastok}" ]; then
      # Try to mount /var/lib/misc from know subvolume locations
      btrfs-mount-subvol (\${root}) /var /@/var
      btrfs-mount-subvol (\${root}) /var/lib/misc /@/var/lib/misc

      # In GRUB it is not possible to map Btrfs IDs to paths; use
      # transactional-update state file as a workaround.
      if [ -e /var/lib/misc/transactional-update.state ]; then
        source /var/lib/misc/transactional-update.state
        health_checker_lastok="\${LAST_WORKING_SNAPSHOTS}"
      fi
    fi

    btrfs-mount-subvol (\$root) /.snapshots @/.snapshots
    for snapshot in \${health_checker_lastok}; do
      if [ -e "/.snapshots/\${snapshot}/grub-snapshot.cfg" ]; then
        menuentry "Previous boot failed; booting snapshot \${snapshot}" { true; }
        source /.snapshots/\${snapshot}/grub-snapshot.cfg
        menuentry "________________" { true; }
        set default=1
      fi
    done
  fi
fi
EOF
